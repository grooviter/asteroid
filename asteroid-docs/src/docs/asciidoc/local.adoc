== Local Transformations

"Local AST transformations are relative to the context they are applied to. In most cases, the context is defined by an
annotation that will define the scope of the transform. For example, annotating a field would mean that the
transformation applies to the field, while annotating the class would mean that the transformation applies to the whole
class."
-- Groovy official site

=== @Local

You can use `@Local` to use an annotation as an AST marker. The only
**mandatory** argument is the AST implementation class. Implementation
classes should always extend `asteroid.LocalTransformationImpl` class.

[source,groovy]
----
include::{testMain}/asteroid/local/samples/AsList.groovy[]
----

If `@Local` annotation is not used in combination with `@Apply` the
transformation is supposed to be used over an element of type `TYPE`,
meaning it will be applied over an entire class.

=== @Apply

`@Apply` is used in combination with `@Local` when the transformation
is applied to any element type other than `TYPE`: a method,
annotation, field...etc.

[source, groovy]
----
include::{testMain}/asteroid/local/samples/WithLogging.groovy[]
----

<1> This annotation will be applied to method elements.
<2> The `@Local` annotation only requires the class of the AST transformation implementation

=== @LocalTransformation

This annotation can only be used when coding a local transformation
implementation using Groovy. It saves some of the boilerplate code
needed to implement an instance of `asteroid.LocalTransformationImpl`.

[source, groovy]
----
include::{testMain}/asteroid/local/samples/AsListImpl.groovy[]
----

<1> This is a local transformation to be applied during `SEMANTIC_ANALYSIS` phase.

This transformation will be applied to those `ClassNode` instances
annotated with `@AsList`.

=== LocalTransformationImpl

`asteroid.LocalTransformationImpl` exists to avoid some of the
defensive code that you would normally write at the beggining of an
AST transformation.

When coding an AST transformation you always check that the first node
is an `AnnotationNode` and the second is the type of `ASTNode` you
expected to be annotated by the first node. Instead of coding that you
can use `LocalTransformationImpl`.

Lets say I have an annotation `@ToMD5`. That annotation can only be
used in elements of type `FIELD`:

[source, groovy]
----
include::{testMain}/asteroid/local/samples/ToMD5.groovy[]
----

I would like to create a method for every field annotated by `ToMD5`
returning the MD5 signature of the content of that field.

In order to implement that I'm using `LocalTransformationImpl`:

[source, groovy]
----
include::{testMain}/asteroid/local/samples/ToMD5Impl.groovy[]
----

<1> Declaring this class as the implementation of a local AST
transformation using `LocalTransformation`
<2> Creating a class extending `LocalTransformationImpl` and declaring
that the annotation and the affected node type are `ToMD5` and
`FieldNode` respectively
<3> The override method declares the correct generic type `FieldNode`.

From this line on you don't have to be worried about casting first and
second node passed to your transformation anymore.

NOTE: Sometimes it comes handy to get a reference to
`org.codehaus.groovy.control.SourceUnit`. In previous version
`SourceUnit` was passed as argument, but it forced to add an import
whether you used or not. Now it's present as a class field. Probably
in future release won't be available directly but through specific
functions.