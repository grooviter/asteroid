<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Asteroid</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Asteroid</h1>
<div class="details">
<span id="revnumber">version 0.5.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_what_is_asteroid">1. What is Asteroid</a></li>
<li><a href="#_show_me_the_code">2. Show me the code</a>
<ul class="sectlevel2">
<li><a href="#_gradle">2.1. Gradle</a></li>
<li><a href="#_example">2.2. Example</a></li>
</ul>
</li>
<li><a href="#_overview">3. Overview</a>
<ul class="sectlevel2">
<li><a href="#_transform_abstractions">3.1. Transform abstractions</a></li>
<li><a href="#_ast_nodes_functions">3.2. AST nodes functions</a>
<ul class="sectlevel3">
<li><a href="#_the_a_class">3.2.1. The A class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_theory">4. Theory</a>
<ul class="sectlevel2">
<li><a href="#_ast">4.1. AST</a>
<ul class="sectlevel3">
<li><a href="#_expressions">4.1.1. Expressions</a></li>
<li><a href="#_statements">4.1.2. Statements</a></li>
<li><a href="#_high_level_nodes">4.1.3. High level Nodes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_local_transformations">5. Local Transformations</a>
<ul class="sectlevel2">
<li><a href="#_overview_2">5.1. Overview</a></li>
<li><a href="#_local">5.2. @Local</a></li>
<li><a href="#_applyto">5.3. <code>applyTo</code></a></li>
<li><a href="#_abstractlocaltransformation">5.4. AbstractLocalTransformation</a></li>
<li><a href="#_phase">5.5. @Phase</a></li>
<li><a href="#_compilation_errors">5.6. Compilation errors</a></li>
<li><a href="#_checks">5.7. Checks</a>
<ul class="sectlevel3">
<li><a href="#_your_own_transformations">5.7.1. Your own transformations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_global_transformations">6. Global Transformations</a>
<ul class="sectlevel2">
<li><a href="#_overview_3">6.1. Overview</a></li>
<li><a href="#_example_2">6.2. Example</a></li>
<li><a href="#_transformers">6.3. Transformers</a>
<ul class="sectlevel3">
<li><a href="#_classnodetransformer">6.3.1. ClassNodeTransformer</a></li>
<li><a href="#_expression_transformers">6.3.2. Expression transformers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_criterias">7. Criterias</a>
<ul class="sectlevel2">
<li><a href="#_transformers_2">7.1. Transformers</a></li>
<li><a href="#_and_or">7.2. and / or</a></li>
<li><a href="#_as_predicates">7.3. As predicates</a></li>
</ul>
</li>
<li><a href="#_fluent_api">8. Fluent API</a>
<ul class="sectlevel2">
<li><a href="#_nodes">8.1. Nodes</a></li>
<li><a href="#_expressions_2">8.2. Expressions</a></li>
<li><a href="#_statements_2">8.3. Statements</a></li>
<li><a href="#_modifiers">8.4. Modifiers</a></li>
<li><a href="#_utils">8.5. Utils</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Asteroid is a set of utilities to make it easier to develop
<a href="http://www.groovy-lang.org">Groovy</a> AST transformations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_asteroid"><a class="anchor" href="#_what_is_asteroid"></a>1. What is Asteroid</h2>
<div class="sectionbody">
<div class="paragraph">
<p>AST transformations, have been historically a hard topic in
Groovy. Asteroid is a set of utilities and ideas trying to reduce the
complexity of dealing with transformations.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Apache</div>
<div class="paragraph">
<p>The <strong>Asteroid</strong> project is open sourced under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2 License</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If you have never done any AST transformation I&#8217;d recommend you to
take a look both the
<a href="http://groovy-lang.org/metaprogramming.html#developing-ast-xforms">Groovy</a>
documentation and the theory chapter. If you already now the stuff
then read on.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
At the moment <strong>Asteroid</strong> development is in an alpha
state. Please check the changelog file to follow the progress of the
project.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_show_me_the_code"><a class="anchor" href="#_show_me_the_code"></a>2. Show me the code</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_gradle"><a class="anchor" href="#_gradle"></a>2.1. Gradle</h3>
<div class="paragraph">
<p>In order to use <code>Asteroid</code> in your Groovy project just add the jcenter
repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">repositories {
    jcenter()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can add the dependency to your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">compile 'com.github.grooviter:asteroid:0.5.0'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example"><a class="anchor" href="#_example"></a>2.2. Example</h3>
<div class="paragraph">
<p>To show the benefit of using Asteroid, I will be following the
tutorial about local transformation available at the
<a href="http://www.groovy-lang.org/metaprogramming.html#transforms-local">Groovy
official site</a>. The code of the following example is available at the
<code>asteroid-test</code> module at
<a href="https://github.com/grooviter/asteroid/tree/master/asteroid-test">Github</a>.</p>
</div>
<div class="paragraph">
<p>Given a code like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@WithLogging</span>
<span class="keyword">def</span> <span class="function">greet</span>() {
    println <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We would like to print a start and stop message along with the message printed by the method itself. So in this
example we&#8217;ll be expecting an output like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">start greet
Hello World
stop greet</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a local transformation only two things are required:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The annotation used as a marker. In this example the <code>@WithLogging</code> annotation</p>
</li>
<li>
<p>The transformation implementation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lets see first the <code>@WithLogging</code> annotation declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(
    value   = WithLoggingTransformationImpl, <i class="conum" data-value="1"></i><b>(1)</b>
    applyTo = Local.TO.METHOD)               <i class="conum" data-value="2"></i><b>(2)</b>
<span class="annotation">@interface</span> WithLogging { }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The transformation implementation class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This annotation will be applied to method elements.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default <code>@Local</code> annotation assumes the annotation is applied to a <code>type</code> (classes). So if you are using the annotation for a type then you could omit <code>value</code> and <code>applyTo</code> attributes an write just the class of the transformation like this: <code>@Local(ImplementationClass)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to implement the transformation. The transformation
should be an instance of
<code>asteroid.local.AbstractLocalTransformation</code>. We have to extend
<code>AbstractLocalTransformation</code> and provide two generic arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The annotation class used to mark our transformation: <code>WithLogging</code></p>
</li>
<li>
<p>The type of nodes that will be affected by this transformation. In this example <code>org.codehaus.groovy.ast.MethodNode</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractLocalTransformation

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>

<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.MethodNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.stmt.Statement</span>

<span class="annotation">@CompileStatic</span>
<span class="annotation">@Phase</span>(Phase.LOCAL.SEMANTIC_ANALYSIS) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">class</span> <span class="class">WithLoggingTransformationImpl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;WithLogging, MethodNode&gt; {

    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(<span class="directive">final</span> AnnotationNode annotation, <span class="directive">final</span> MethodNode methodNode) {
        <span class="keyword">def</span> before = printlnS(<span class="string"><span class="delimiter">&quot;</span><span class="content">start</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="keyword">def</span> after = printlnS(<span class="string"><span class="delimiter">&quot;</span><span class="content">end</span><span class="delimiter">&quot;</span></span>)   <i class="conum" data-value="3"></i><b>(3)</b>

        A.UTIL.NODE.addAroundCodeBlock(methodNode, before, after) <i class="conum" data-value="4"></i><b>(4)</b>
    }

    <span class="predefined-type">Statement</span> printlnS(<span class="predefined-type">String</span> message) {
        <span class="keyword">return</span> A.STMT.stmt(A.EXPR.callThisX(<span class="string"><span class="delimiter">&quot;</span><span class="content">println</span><span class="delimiter">&quot;</span></span>, A.EXPR.constX(message))) <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Phase</code> annotation indicates in which compilation phase this transformation will be applied.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Building <code>println "start"</code> code, which is wrapped in a <code>org.codehaus.groovy.ast.stmt.Statement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Building <code>println "end"</code> code, which is wrapped in a <code>org.codehaus.groovy.ast.stmt.Statement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Building the new method code re-arranging the new and old code in order.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Building a generic <code>println constantValue</code> expression</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>@CompileStatic</code> annotation is not required it&#8217;s only used here to highlight that all the code used in this
transformation is safely typed and can be optimized by this annotation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>3. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the moment Asteroid is composed by two main groups, abstractions to
reduce the complexity of creating a new transformation, and utility
classes helping to create new Abstract Syntaxt Tree nodes.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-3d88762fd9c78b784fad4a7619ee27bd.png" alt="Diagram" width="1000" height="224">
</div>
</div>
<div class="sect2">
<h3 id="_transform_abstractions"><a class="anchor" href="#_transform_abstractions"></a>3.1. Transform abstractions</h3>
<div class="paragraph">
<p>So far abstractions used to deal with the AST were too low level. For
instance, you needed to check whether the nodes passed to your
transformation were the ones you wanted to act over or not, and then
proceed.</p>
</div>
<div class="paragraph">
<p>Asteroid tries to provide higher abstractions in order to reduce some
of the boiler plate code, and make the developer to focus on the
transformation only.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ast_nodes_functions"><a class="anchor" href="#_ast_nodes_functions"></a>3.2. AST nodes functions</h3>
<div class="paragraph">
<p>The other main part of Asteroid are functions dealing directly with
AST nodes. Functions responsible for modifying AST nodes.</p>
</div>
<div class="paragraph">
<p>They&#8217;re divided in four groups:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Expressions</strong>: Functions responsible for creating expressions</p>
</li>
<li>
<p><strong>Statements</strong>: Functions responsible for creating statements</p>
</li>
<li>
<p><strong>Nodes</strong>: Builders responsible for creating high level nodes</p>
</li>
<li>
<p><strong>Utils</strong>: Functions responsible for querying and querying any type of nodes</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
With the upcoming <code>groovy-macro</code> module in Groovy 2.5.0 most
of the code in Asteroid, used for creating <code>expressions</code> and
<code>statements</code> may be gone for good in favor of the <code>macro</code> method.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_a_class"><a class="anchor" href="#_the_a_class"></a>3.2.1. The A class</h4>
<div class="paragraph">
<p>All functions available in Asteroid are accessible through the
<code>asteroid.A</code> class.</p>
</div>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/A.html"><code>asteroid.A</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_theory"><a class="anchor" href="#_theory"></a>4. Theory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What can you do with an AST transformation ?</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Transform</strong> the Abstract Syntax Tree by adding, or removing
elements from it</p>
</li>
<li>
<p><strong>Check</strong> the structure, or semantics of the Abstract Syntax Tree and do
something about it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples of <strong>adding / removing</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><a href="http://groovy-lang.org/metaprogramming.html#_code_generation_transformations">Groovy</a></strong>: Code generation transformations: @ToString, @Immutable&#8230;&#8203;</p>
</li>
<li>
<p><strong><a href="https://github.com/spockframework/spock">Spock</a></strong>: transforms label statements</p>
</li>
<li>
<p><strong><a href="https://github.com/Arasthel/SwissKnife">Swissknife</a></strong>: reduces boilerplate code in Android dev</p>
</li>
<li>
<p><strong><a href="https://grails.org/">Grails</a></strong>: also saves you from typical web boilerplate code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/grails.png" alt="grails" width="100"></span> <span class="image"><img src="images/spock.png" alt="spock" width="100"></span> <span class="image"><img src="images/swissknife.png" alt="swissknife" width="100" height="100"></span> <span class="image"><img src="images/griffon.png" alt="griffon" width="100"></span></p>
</div>
<div class="paragraph">
<p>Examples of <strong>checking</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><a href="https://github.com/andresteingress/gcontracts">GContracts</a></strong>: programming by contract</p>
</li>
<li>
<p><strong><a href="https://github.com/CodeNarc/CodeNarc">Codenarc</a></strong>: Static Analysis</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/codenarc.png" alt="codenarc" height="100"></span></p>
</div>
<div class="paragraph">
<p>Transformations can be of two types:</p>
</div>
<div class="paragraph">
<p><strong>Local</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Relative to the context they are applied to.</p>
</li>
<li>
<p>That context is marked (annotation)</p>
</li>
<li>
<p>Compilation phases are limited</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Global</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Global AST transformations are applied to all source code</p>
</li>
<li>
<p>Compilation phases are less limited</p>
</li>
<li>
<p>Need an extra descriptor file</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_ast"><a class="anchor" href="#_ast"></a>4.1. AST</h3>
<div class="paragraph">
<p>Abstract Syntax Tree (or AST from now on) is the tree-like
representation of the code the compiler needs in order to
generate the bytecode that will be used later by the JVM.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-90c65edb8b6019b954745a0b6e4e1d2c.png" alt="Diagram" width="490" height="98">
</div>
</div>
<div class="paragraph">
<p>When dealing with the AST, most of the time we will talking about
three types of elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>EXPRESSIONS</strong></p>
</li>
<li>
<p><strong>STATEMENTS</strong></p>
</li>
<li>
<p><strong>HIGH LEVEL</strong> NODES</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-d92f8c70927e36f28b268b696082cc1d.png" alt="Diagram" width="580" height="336">
</div>
</div>
<div class="sect3">
<h4 id="_expressions"><a class="anchor" href="#_expressions"></a>4.1.1. Expressions</h4>
<div class="paragraph">
<p>An <strong>expression</strong> is a <strong>combination</strong> of one or more explicit
<strong>values, constants, variables, operators, and functions</strong> that the
programming language interprets and computes <strong>to produce another
value</strong>.</p>
</div>
<div class="listingblock">
<div class="title">BinaryExpression</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="integer">1</span> == <span class="integer">1</span></code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-2cfa973c8aa0bacc7337aa8244a9e882.png" alt="Diagram" width="250" height="196">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>constant</strong> expression <em>1</em></p>
</li>
<li>
<p><strong>token</strong> <em>==</em></p>
</li>
<li>
<p><strong>constant</strong> expression <em>1</em></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Method call expression</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">ref.myMethod(<span class="integer">3</span>)</code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-3a7dd8bb44048094b238a630e859a401.png" alt="Diagram" width="650" height="182">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>variable</strong> expression <em>ref</em></p>
</li>
<li>
<p><strong>constant</strong> <em>myMethod</em></p>
</li>
<li>
<p><strong>param</strong> expression <em>3</em></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_statements"><a class="anchor" href="#_statements"></a>4.1.2. Statements</h4>
<div class="paragraph">
<p>In computer programming, a statement is the <strong>smallest standalone
element</strong> of an imperative programming language that <strong>expresses some
action to be carried out</strong>. A statement may have <strong>expressions</strong>.</p>
</div>
<div class="listingblock">
<div class="title">If Statement</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span>(booleanExpression) {
 println <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> <span class="comment">// statement</span>
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>expression</strong> to evaluate</p>
</li>
<li>
<p><strong>statement</strong> to be executed if the boolean expression evaluates to true</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Block Statement</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">public</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) { <span class="comment">// block starts</span>
  <span class="comment">// this is inside a block statement</span>
} <span class="comment">// block ends</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A block statement is easily recognized by <strong>curly braces</strong></p>
</li>
<li>
<p>It is built from other <strong>statements</strong> containing <strong>expressions</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Block Statement (Cont.)</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="directive">public</span> <span class="predefined-type">String</span> greetings() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello Greach</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This block statement contains a <strong>return</strong> statement receiving a constant
expression <strong>Hello Greach</strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_high_level_nodes"><a class="anchor" href="#_high_level_nodes"></a>4.1.3. High level Nodes</h4>
<div class="paragraph">
<p>Is <strong>how our program is structured</strong>. They group statements and
  expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>classes</strong></p>
</li>
<li>
<p><strong>methods</strong></p>
</li>
<li>
<p><strong>fields</strong></p>
</li>
<li>
<p><strong>properties</strong></p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Class Node</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">A</span> { <span class="comment">// ClassNode</span>
   <span class="predefined-type">String</span> greetings <span class="comment">// FieldNode</span>

   <span class="predefined-type">String</span> hello() { <span class="comment">// MethodNode</span>

   }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>ClassNode</strong> may contain: methods, fields&#8230;&#8203;</p>
</li>
<li>
<p><strong>MethodNode</strong> may contain statements, and expressions</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">A</span> { <span class="comment">// ClassNode</span>

   <span class="predefined-type">String</span> hello() <span class="comment">// MethodNode</span>
   { <span class="comment">// blockStatement {</span>

       <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span> <span class="comment">// returnStatement(constantExpression)</span>

    } <span class="comment">// }</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_local_transformations"><a class="anchor" href="#_local_transformations"></a>5. Local Transformations</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Local AST transformations are relative to the context they are applied to. In most cases, the context is defined by an
annotation that will define the scope of the transform. For example, annotating a field would mean that the
transformation applies to the field, while annotating the class would mean that the transformation applies to the whole
class.
</blockquote>
<div class="attribution">
&#8212; Groovy official site
</div>
</div>
<div class="sect2">
<h3 id="_overview_2"><a class="anchor" href="#_overview_2"></a>5.1. Overview</h3>
<div class="paragraph">
<p>In order to create a local transformation you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create an <code>annotation</code> annotated by <code>@Local</code></p>
</li>
<li>
<p>Create an <code>implementation</code> of the transformation extending <code>AbstractLocalTransformation</code></p>
</li>
<li>
<p>Your implementation should be annotated by <code>@Phase</code> with the proper
local compilation phase value set.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_local"><a class="anchor" href="#_local"></a>5.2. @Local</h3>
<div class="paragraph">
<p>In a local transformation you normally use an annotation to mark those
parts of the code you want to transform: classes, methods&#8230;&#8203; That
annotation should be annotated as well to tell the compiler that is
going to be used as a transformation marker.</p>
</div>
<div class="paragraph">
<p>You can use <code>@Local</code> to annotate a marker annotation. The only
<strong>mandatory</strong> argument is the AST implementation class. Implementation
classes should always extend
<code>asteroid.local.AbstractLocalTransformation</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(AsListImpl)
<span class="annotation">@interface</span> AsList { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>@Local</code> annotation does not indicate which type of element is
allowed to annotate by the attribute <code>appliedTo</code> then is supposed to
be used over an element of type <code>TYPE</code>, meaning it will be applied
over an entire class.</p>
</div>
<div class="paragraph">
<p>Underneath the <code>@Local</code> annotation is doing:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-3059a27b1460fdfd4879fcc8213ebf53.png" alt="Diagram" width="1060" height="168">
</div>
<div class="title">Figure 1. Local annotation transformation</div>
</div>
</div>
<div class="sect2">
<h3 id="_applyto"><a class="anchor" href="#_applyto"></a>5.3. <code>applyTo</code></h3>
<div class="paragraph">
<p><code>applyTo</code> attribute is used when the transformation is applied to any
element type other than <code>TYPE</code>: a method, annotation, field&#8230;&#8203;etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(
    value   = WithLoggingTransformationImpl, <i class="conum" data-value="1"></i><b>(1)</b>
    applyTo = Local.TO.METHOD)               <i class="conum" data-value="2"></i><b>(2)</b>
<span class="annotation">@interface</span> WithLogging { }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation will be applied to method elements.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The class of the AST transformation implementation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes you may want to target more than one element: a class and
a method, or a parameter and a local variable. Then you can use
<code>TO.ANNOTATED</code> that means that the transformation could be applied
to any annotated node.</p>
</div>
<div class="listingblock">
<div class="title">annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(value = NameCheckerImpl, applyTo = Local.TO.ANNOTATED)
<span class="annotation">@interface</span> NameChecker {
    <span class="predefined-type">String</span> value()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most of the times a single node type is targeted. That
idea was kept in mind when creating the <code>applyTo</code> parameter. That&#8217;s
why <code>applyTo</code> doesn&#8217;t receive a list of possible targets. <code>ANNOTATED</code>
is the exception to the rule that allows to do so.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Therefore in your implementation you should
use the <code>AnnotatedNode</code> type.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The following example of method overriding only works with dynamic Groovy, if
you statically compiled the code it would only be executing <code>getName(AnnotatedNode)</code>. So
if you compile your code statically you should probably be using a <code>instanceof</code> to
dispatch your actions.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">implementation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.AbstractLocalTransformation
<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotatedNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.FieldNode</span>

<span class="comment">/**
 * Checks whether an {@link AnnotatedNode} follows the defined pattern in the
 * pattern property
 *
 * @since 0.2.5
 */</span>
<span class="annotation">@Phase</span>(Phase.LOCAL.INSTRUCTION_SELECTION)
<span class="type">class</span> <span class="class">NameCheckerImpl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;NameChecker, AnnotatedNode&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(AnnotationNode annotation, AnnotatedNode annotated) { <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="predefined-type">String</span> pattern = A.UTIL.NODE.getStringValue(annotation)
        <span class="predefined-type">String</span> nodeText = getName(annotated)
        <span class="predefined-type">Boolean</span> matches = nodeText ==~ pattern

        <span class="keyword">if</span> (!matches) {
            addError <span class="string"><span class="delimiter">'</span><span class="content">Pattern doesn</span><span class="char">\'</span><span class="content">t match annotated name</span><span class="delimiter">'</span></span>, annotated
        }
    }

    <span class="predefined-type">String</span> getName(ClassNode classNode){  <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="keyword">return</span> classNode.name
    }

    <span class="predefined-type">String</span> getName(FieldNode fieldNode) { <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="keyword">return</span> fieldNode.name
    }

    <span class="predefined-type">String</span> getName(AnnotatedNode annotatedNode) { <i class="conum" data-value="5"></i><b>(5)</b>
        addError <span class="string"><span class="delimiter">&quot;</span><span class="content">Pattern doesn't match annotated name</span><span class="delimiter">&quot;</span></span>, annotatedNode
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You expect to receive any type of node extending <code>AnnotatedNode</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Receiving the annotated node as a parameter</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Executing logic if the node is of type <code>ClassNode</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Executing logic if the node is of type <code>FieldNode</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Executing logic if the node is of any other type extending <code>AnnotatedNode</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then you can use it in any annotated node:</p>
</div>
<div class="listingblock">
<div class="title">example</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="annotation">@NameChecker</span>(<span class="string"><span class="delimiter">'</span><span class="content">.*Subject</span><span class="delimiter">'</span></span>)
<span class="type">class</span> <span class="class">CheckerSubject</span> {

  <span class="annotation">@NameChecker</span>(<span class="string"><span class="delimiter">'</span><span class="content">.*Field</span><span class="delimiter">'</span></span>)
  <span class="predefined-type">String</span> stringField = <span class="string"><span class="delimiter">'</span><span class="content">doSomething</span><span class="delimiter">'</span></span>
}

<span class="keyword">assert</span> <span class="keyword">new</span> CheckerSubject().stringField == <span class="string"><span class="delimiter">'</span><span class="content">doSomething</span><span class="delimiter">'</span></span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_abstractlocaltransformation"><a class="anchor" href="#_abstractlocaltransformation"></a>5.4. AbstractLocalTransformation</h3>
<div class="paragraph">
<p><code>asteroid.local.AbstractLocalTransformation</code> exists to avoid some of the
defensive code that you would normally write at the beggining of an
AST transformation.</p>
</div>
<div class="paragraph">
<p>When coding an AST transformation you always check that the first node
is an <code>AnnotationNode</code> and the second is the type of <code>ASTNode</code> you
expected to be annotated by the first node. Instead of coding that you
can use <code>AbstractLocalTransformation</code>.</p>
</div>
<div class="paragraph">
<p>Lets say I have an annotation <code>@ToMD5</code>. That annotation can only be
used in elements of type <code>FIELD</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(value = ToMD5Impl, applyTo = Local.TO.FIELD)
<span class="annotation">@interface</span> ToMD5 { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I would like to create a method for every field annotated by <code>ToMD5</code>
returning the MD5 signature of the content of that field.</p>
</div>
<div class="paragraph">
<p>In order to implement that I&#8217;m using <code>AbstractLocalTransformation</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractLocalTransformation

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>

<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.FieldNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.MethodNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.stmt.BlockStatement</span>

<span class="annotation">@CompileStatic</span>
<span class="annotation">@Phase</span>(Phase.LOCAL.SEMANTIC_ANALYSIS) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">class</span> <span class="class">ToMD5Impl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;ToMD5, FieldNode&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(AnnotationNode annotation, FieldNode node) { <i class="conum" data-value="3"></i><b>(3)</b>
        BlockStatement block  = buildMethodCode(node.name)
        MethodNode methodNode = A.NODES.method(<span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>node.name<span class="inline-delimiter">}</span></span><span class="content">ToMD5</span><span class="delimiter">&quot;</span></span>)
            .modifiers(A.ACC.ACC_PUBLIC)
            .returnType(<span class="predefined-type">String</span>)
            .code(block)
            .build()

        A.UTIL.NODE.addMethod(node.declaringClass, methodNode)
    }

    <span class="directive">private</span> BlockStatement buildMethodCode(<span class="directive">final</span> <span class="predefined-type">String</span> name) {
        A.STMT.blockSFromString <span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
            return java.security.MessageDigest
                .getInstance('MD5')
                .digest(</span><span class="inline"><span class="inline-delimiter">${</span>name<span class="inline-delimiter">}</span></span><span class="content">.getBytes())
                .encodeHex()
                .toString()
        </span><span class="delimiter">&quot;&quot;&quot;</span></span>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declaring when to apply this transformation with the annotation
<code>@Phase</code> and the correspondent compilation phase.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creating a class extending <code>AbstractLocalTransformation</code> and declaring
that the annotation and the affected node type are <code>ToMD5</code> and
<code>FieldNode</code> respectively</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The override method declares the correct generic type <code>FieldNode</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From this line on you don&#8217;t have to be worried about casting first and
second node passed to your transformation anymore.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sometimes it comes handy to get a reference to
<code>org.codehaus.groovy.control.SourceUnit</code>. In previous versions
<code>SourceUnit</code> was passed as argument, but it forced to add an import
whether you used or not. Now it&#8217;s present as a class field. Probably
in future release won&#8217;t be available directly but through specific
functions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_phase"><a class="anchor" href="#_phase"></a>5.5. @Phase</h3>
<div class="paragraph">
<p><code>@Phase</code> is a <strong>required</strong> annotation for both <code>global</code> and <code>local</code>
transformations that indicates in which compilation phase this
transformation will be applied.</p>
</div>
<div class="paragraph">
<p>Lets see how <code>@Phase</code> annotation is processed in a local transformation:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diag-e362fb1ad4f6847f00d4c2b1cc1064b1.png" alt="Diagram" width="1130" height="154">
</div>
<div class="title">Figure 2. Local Transformation</div>
</div>
<div class="paragraph">
<p><code>@Phase</code> annotation needs a value of type
<code>org.codehaus.groovy.control.CompilePhase</code> enum, but because sometimes
is hard to remember which phases are available depending on which type
of transformation we are implementing and it would add one more import
to our code, <code>Asteroid</code> provides a shortcut to these values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>asteroid.Phase.LOCAL</code></p>
</li>
<li>
<p><code>asteroid.Phase.GLOBAL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This way is always easier to remember how to get the proper
compilation phase. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractLocalTransformation

<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>

<span class="annotation">@Phase</span>(Phase.LOCAL.SEMANTIC_ANALYSIS) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">class</span> <span class="class">AsListImpl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;AsList, ClassNode&gt; {

    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(AnnotationNode annotation, ClassNode classNode) {
        classNode.superClass = A.NODES.clazz(<span class="predefined-type">ArrayList</span>).build()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is a local transformation to be applied during <code>SEMANTIC_ANALYSIS</code> phase.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This transformation will be applied to those <code>ClassNode</code> instances
annotated with <code>@AsList</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Groovy friendly</div>
<div class="paragraph">
<p>When used over a local transformation implementation in Groovy, apart
from indicating the compilation phase, underneath, it saves some of
the boilerplate code needed to implement an instance of
<code>asteroid.local.AbstractLocalTransformation</code>.</p>
</div>
<div class="paragraph">
<p>Although you can create an <code>AbstractLocalTransformation</code> in
plain Java, you then will have to annotate your transformations like
the old days.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compilation_errors"><a class="anchor" href="#_compilation_errors"></a>5.6. Compilation errors</h3>
<div class="paragraph">
<p>If at some point you would like to stop the compilation process the
best approach is to use <code>addError</code> method. This method is available
in both <code>AbstractLocalTransformation</code> and <code>AbstractGlobalTransformation</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractLocalTransformation

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>

<span class="annotation">@CompileStatic</span>
<span class="annotation">@Phase</span>(Phase.LOCAL.SEMANTIC_ANALYSIS)
<span class="type">class</span> <span class="class">GrumpyImpl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;Grumpy, ClassNode&gt; {

    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(AnnotationNode annotation, ClassNode clazz) {
        addError(<span class="string"><span class="delimiter">&quot;</span><span class="content">I don't like you Argggg!!!!! (said the Grumpy transformation)</span><span class="delimiter">&quot;</span></span>, clazz)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_checks"><a class="anchor" href="#_checks"></a>5.7. Checks</h3>
<div class="paragraph">
<p>There are many times when you have to check if all precoditions are
correct before applying a given transformation. Without this sanity
check, many things could go wrong. Checks labels are an effort to
avoid boiler plate code when checking the AST state. They are inspired
in Spock blocks.</p>
</div>
<div class="paragraph">
<p>By default checks labels are available in Asteroid local
transformations. All you have to do is to structure your code using
labels <code>check</code> and <code>then</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example, it&#8217;s a bit silly but I think it will easy to
understand. We have a annotation called <code>@Serializable</code>.</p>
</div>
<div class="paragraph">
<p>The transformation <code>SerializableImpl</code> will make all classes annotated
with <code>@Serializable</code> to implement <code>java.io.Serializable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> asteroid.Local

<span class="annotation">@Local</span>(SerializableImpl)
<span class="annotation">@interface</span> <span class="predefined-type">Serializable</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As constraints I want to make sure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The annotated class package name should should start by 'asteroid'</p>
</li>
<li>
<p>The annotated class can only have two method at most</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.local.samples

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.AnnotationNode</span>

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractLocalTransformation

<span class="annotation">@CompileStatic</span>
<span class="annotation">@Phase</span>(Phase.LOCAL.INSTRUCTION_SELECTION)
<span class="type">class</span> <span class="class">SerializableImpl</span> <span class="directive">extends</span> AbstractLocalTransformation&lt;<span class="predefined-type">Serializable</span>, ClassNode&gt; {

    <span class="annotation">@Override</span>
    <span class="type">void</span> doVisit(AnnotationNode annotation, ClassNode classNode) {
        <span class="key">check</span>: <span class="string"><span class="delimiter">'</span><span class="content">package starts with asteroid</span><span class="delimiter">'</span></span>
        classNode.packageName.startsWith(<span class="string"><span class="delimiter">'</span><span class="content">asteroid</span><span class="delimiter">'</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>

        <span class="key">check</span>: <span class="string"><span class="delimiter">'</span><span class="content">there are least than 2 methods</span><span class="delimiter">'</span></span>
        classNode.methods.size() &lt; <span class="integer">2</span> <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="key">then</span>: <span class="string"><span class="delimiter">'</span><span class="content">make it implements Serializable and Cloneable</span><span class="delimiter">'</span></span>
        A.UTIL.NODE.addInterfaces(classNode, java.io.Serializable, <span class="predefined-type">Cloneable</span>) <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Checking the annotated class belongs to a certain <code>package</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Checking that the annotated node has less than two methods</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Transformation code</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Limitations</div>
<div class="paragraph">
<p>Please notice at the moment checks only have a very limited
functionality. They only allow a <strong>one-line</strong> expression. And these
expressions can only see <code>doVisit</code> parameter values.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>To prove it, there&#8217;s a test with an annotated class having two
methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">    <span class="type">void</span> testFailsBecauseNumberOfMethods() {
        shouldFail <span class="string"><span class="delimiter">'''</span><span class="content">
        package asteroid.local.samples

        @Serializable
        class A {
            def a() {}
            def b() {}
        }
        </span><span class="delimiter">'''</span></span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the test&#8230;&#8203; passes :)</p>
</div>
<div class="sect3">
<h4 id="_your_own_transformations"><a class="anchor" href="#_your_own_transformations"></a>5.7.1. Your own transformations</h4>
<div class="paragraph">
<p>If you would like to add this functionality in your project, you can
use Asteroid utility functions to inject this behavior in your code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">A.UTIL.NODE.addCheckTo(A.UTIL.NODE.findMethodByName(annotatedNode, METHOD_DOVISIT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This call is taken from Asteroid local transformations. Checking is added to method <code>doVisit</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_global_transformations"><a class="anchor" href="#_global_transformations"></a>6. Global Transformations</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
Global AST transformation are similar to local one with a major
difference: they do not need an annotation, meaning that they are
applied globally, that is to say on each class being compiled. It is
therefore very important to limit their use to last resort, because it
can have a significant impact on the compiler performance.
</blockquote>
<div class="attribution">
&#8212; Groovy official site
</div>
</div>
<div class="sect2">
<h3 id="_overview_3"><a class="anchor" href="#_overview_3"></a>6.1. Overview</h3>
<div class="paragraph">
<p><code>Asteroid</code> suggest a certain way of creating global AST
transformations. Instead of creating a global transformation and
manipulate the <code>SourceUnit</code> directly, an <code>Asteroid</code> global
transformation only holds references to code transformers.</p>
</div>
<div class="paragraph">
<p>In order to create a global transformation you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create an <code>implementation</code> of the transformation extending
<code>AbstractGlobalTransformation</code></p>
</li>
<li>
<p>Create as many <code>transfomers</code> as you need and then make the
<code>getTransformers</code> method from your transformation to return the
classes of those transformers.</p>
</li>
<li>
<p>Your implementation should be annotated by <code>@Phase</code> with the proper
local compilation phase value set.</p>
</li>
<li>
<p>Add a <code>transformation descriptor</code> in your classpath to tell the
compiler where it can find your transformation</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_example_2"><a class="anchor" href="#_example_2"></a>6.2. Example</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.global.samples

<span class="keyword">import</span> <span class="include">static</span> asteroid.Phase.GLOBAL

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>

<span class="keyword">import</span> asteroid.Phase
<span class="keyword">import</span> asteroid.AbstractGlobalTransformation
<span class="keyword">import</span> asteroid.transformer.Transformer

<span class="annotation">@CompileStatic</span>
<span class="annotation">@Phase</span>(GLOBAL.CONVERSION) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">class</span> <span class="class">AddTransformation</span> <span class="directive">extends</span> AbstractGlobalTransformation { <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="annotation">@Override</span>
    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Class</span>&lt;<span class="predefined-type">Transformer</span>&gt;&gt; getTransformers() {
        <span class="keyword">return</span> [AddPropertyToInnerClass, AddTraitTransformer] <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declaring class as a global AST transformation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Extending <code>asteroid.global.GlobalTransformationImpl</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding <code>asteroid.global.AbstractClassNodeTransformer</code> classes</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A global transformation needs to be annotated with the
<code>@GlobalTransformation</code> annotation, then it should extend
<code>GlobalTransformationImpl</code> and finally to provide a list of the
transformers that will eventually transform the code.</p>
</div>
<div class="paragraph">
<p>In this example the code of the transformer is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.global.samples

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>

<span class="keyword">import</span> <span class="include">org.codehaus.groovy.control.SourceUnit</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.transformer.AbstractClassNodeTransformer

<span class="annotation">@CompileStatic</span>
<span class="type">class</span> <span class="class">AddPropertyToInnerClass</span> <span class="directive">extends</span> AbstractClassNodeTransformer { <i class="conum" data-value="1"></i><b>(1)</b>

    AddPropertyToInnerClass(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(sourceUnit,
              A.CRITERIA.byClassNodeNameContains(<span class="string"><span class="delimiter">'</span><span class="content">AddTransformerSpecExample$Input</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@Override</span>
    <span class="type">void</span> transformClass(<span class="directive">final</span> ClassNode target) { <i class="conum" data-value="3"></i><b>(3)</b>
        A.UTIL.NODE.addInterfaces(target, java.io.Serializable)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because this transformer targets class nodes it extends <code>ClassNodeTransformer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Every <code>ClassNodeTransformer</code> requires a <code>SourceUnit</code> and a
criteria to filter class nodes</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then the programmer should only be focused on develop de
transformation within the <code>transformClass</code> method</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally add the descriptor file to your classpath at
<code>META-INF/services/</code> the descriptor file should be named
<code>org.codehaus.groovy.transform.ASTTransformation</code>, and it will
contain the fully qualified name of your AST transformation implementation:
<code>asteroid.global.samples.AddTransformationImpl</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using <code>Gradle</code> or <code>Maven</code> the transformation
descriptor will be normally found at
<code>src/main/resources/META-INF/org.codehaus.groovy.transform.ASTTransformation</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that for any new global transformation you should add
the new qualified class in a new line.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_transformers"><a class="anchor" href="#_transformers"></a>6.3. Transformers</h3>
<div class="paragraph">
<p>Because a global AST transformation can act over the whole source
code, we use transformers to focus only on certain parts of
it. Transformers theirselves declare which type of nodes they are
interested in, but, they also use <code>criterias</code> to narrow the search.</p>
</div>
<div class="sect3">
<h4 id="_classnodetransformer"><a class="anchor" href="#_classnodetransformer"></a>6.3.1. ClassNodeTransformer</h4>
<div class="paragraph">
<p>This type of transformers only focuses on transforming a specific set
of <code>ClassNode</code> instances from the AST.</p>
</div>
<div class="listingblock">
<div class="title">ClassNodeTransformer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">AddImportTransformer</span> <span class="directive">extends</span> AbstractClassNodeTransformer { <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> AddImportTransformer(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(sourceUnit,
              A.CRITERIA.byAnnotationSimpleName(<span class="string"><span class="delimiter">'</span><span class="content">AddImport</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>

    }

    <span class="comment">/**
     * {@inheritDocs}
     */</span>
    <span class="annotation">@Override</span>
    <span class="type">void</span> transformClass(<span class="directive">final</span> ClassNode target) { <i class="conum" data-value="3"></i><b>(3)</b>
        A.UTIL.NODE.addImport(target, groovy.json.JsonOutput) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Extending <code>ClassNodeTransformer</code> we are only interested in
<code>ClassNode</code> instances</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then we use a <code>criteria</code> to declare we&#8217;re only interested in
<code>ClassNode</code> instances annotated by an annotation which has a simple
name <code>AddImport</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Overriding the <code>transformClass</code> method we will be receiving the
expected <code>ClassNode</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We don&#8217;t return anything because we are modifying the node, we are
not supposed to replace it in the AST.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Why <code>simple name</code> ? Well depending on the compilation phase you
are targeting the information about the class may be not available,
that means it&#8217;s fully qualified name.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Transforming an AST node here means to add/remove elements
from the AST node.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_expression_transformers"><a class="anchor" href="#_expression_transformers"></a>6.3.2. Expression transformers</h4>
<div class="paragraph">
<p>This type of transformers only focuses on <strong>replacing</strong> certain
expressions found along the AST.</p>
</div>
<div class="paragraph">
<p>In the following example, we are interested in replacing all method
calls <code>xxx()</code> by a constant number <code>1</code>.</p>
</div>
<div class="listingblock">
<div class="title">ExpressionTransformer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">ChangeTripleXToPlusOne</span>
    <span class="directive">extends</span> AbstractExpressionTransformer&lt;MethodCallExpression&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    ChangeTripleXToPlusOne(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(MethodCallExpression,
              sourceUnit,
              A.CRITERIA.byExprMethodCallByName(<span class="string"><span class="delimiter">'</span><span class="content">xxx</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@Override</span>
    <span class="predefined-type">Expression</span> transformExpression(<span class="directive">final</span> MethodCallExpression target) { <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="keyword">return</span> A.EXPR.constX(<span class="integer">1</span>)  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We declare this transformer is focused on <code>MethodCallExpression</code>
elements</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We declare we are only interested on method calls with name <code>xxx</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Overriding the transformExpression operation we will be receiving
the expected node</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Finally will be returning the expression that will replace the
former expression in the AST</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It&#8217;s very important to notice the fact that we are here
replacing an expression cause expressions are considered as values.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_criterias"><a class="anchor" href="#_criterias"></a>7. Criterias</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every time we want to apply a transformation we want to target
specific nodes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A method with a specific <code>annotation</code></p>
</li>
<li>
<p>A class with a specific <code>annotation</code></p>
</li>
<li>
<p>A method with a specific <code>name</code></p>
</li>
<li>
<p>A method with a specific name <code>and</code> a specific annotation</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Instead of holding a node reference and start calling methods from
that reference in order to find out which is the node we are
interested in, we can use criterias.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Criterias are available directly as static nodes in the
<a href="javadocs/asteroid/Criterias.html"><code>asteroid.Criterias</code></a> or via
<a href="javadocs/asteroid/A.html"><code>A.CRITERIA</code></a>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_transformers_2"><a class="anchor" href="#_transformers_2"></a>7.1. Transformers</h3>
<div class="paragraph">
<p>Lets say we would like to apply a given transformation to a specific
set of classes annotated with a certain annotation.</p>
</div>
<div class="listingblock">
<div class="title">Criteria</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">AddImportTransformer</span> <span class="directive">extends</span> AbstractClassNodeTransformer { <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> AddImportTransformer(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(sourceUnit,
              A.CRITERIA.byAnnotationSimpleName(<span class="string"><span class="delimiter">'</span><span class="content">AddImport</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>

    }

    <span class="comment">/**
     * {@inheritDocs}
     */</span>
    <span class="annotation">@Override</span>
    <span class="type">void</span> transformClass(<span class="directive">final</span> ClassNode target) { <i class="conum" data-value="3"></i><b>(3)</b>
        A.UTIL.NODE.addImport(target, groovy.json.JsonOutput) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a class node transformer</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Looking for a class node annotated with an annotation with name <code>AddImport</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What about looking for a <code>ClassNode</code> representing an inner class
having a specific name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">package</span> asteroid.global.samples

<span class="keyword">import</span> <span class="include">groovy.transform.CompileStatic</span>

<span class="keyword">import</span> <span class="include">org.codehaus.groovy.control.SourceUnit</span>
<span class="keyword">import</span> <span class="include">org.codehaus.groovy.ast.ClassNode</span>

<span class="keyword">import</span> asteroid.A
<span class="keyword">import</span> asteroid.transformer.AbstractClassNodeTransformer

<span class="annotation">@CompileStatic</span>
<span class="type">class</span> <span class="class">AddPropertyToInnerClass</span> <span class="directive">extends</span> AbstractClassNodeTransformer { <i class="conum" data-value="1"></i><b>(1)</b>

    AddPropertyToInnerClass(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(sourceUnit,
              A.CRITERIA.byClassNodeNameContains(<span class="string"><span class="delimiter">'</span><span class="content">AddTransformerSpecExample$Input</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@Override</span>
    <span class="type">void</span> transformClass(<span class="directive">final</span> ClassNode target) { <i class="conum" data-value="3"></i><b>(3)</b>
        A.UTIL.NODE.addInterfaces(target, java.io.Serializable)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again looking for a class node</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>With a name containing a specific <code>Outer$Inner</code> class name</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now a different example. Instead of targeting a <code>ClassNode</code> we would
like to find a specific method call expression. We know what is the
name of the method we are calling, that&#8217;s why we use
<code>methodCallByName</code> criteria here:</p>
</div>
<div class="listingblock">
<div class="title">ExpressionTransformer</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">ChangeTripleXToPlusOne</span>
    <span class="directive">extends</span> AbstractExpressionTransformer&lt;MethodCallExpression&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    ChangeTripleXToPlusOne(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(MethodCallExpression,
              sourceUnit,
              A.CRITERIA.byExprMethodCallByName(<span class="string"><span class="delimiter">'</span><span class="content">xxx</span><span class="delimiter">'</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@Override</span>
    <span class="predefined-type">Expression</span> transformExpression(<span class="directive">final</span> MethodCallExpression target) { <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="keyword">return</span> A.EXPR.constX(<span class="integer">1</span>)  <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_and_or"><a class="anchor" href="#_and_or"></a>7.2. and / or</h3>
<div class="paragraph">
<p>Sometimes using only one criteria could be limiting, sometimes we may
want to combine two or more criterias at once. For that purpose you can
use <code>A.CRITERIA.and</code> and <code>A.CRITERIA.or</code>. Check next example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">AddLoggerTransformer</span> <span class="directive">extends</span> AbstractClassNodeTransformer {

    <span class="directive">static</span> <span class="directive">final</span> Closure&lt;<span class="predefined-type">Boolean</span>&gt; CRITERIA = <i class="conum" data-value="1"></i><b>(1)</b>
        A.CRITERIA.with {
            and(byClassNodeNameStartsWith(<span class="string"><span class="delimiter">'</span><span class="content">asteroid.global.samples</span><span class="delimiter">'</span></span>),
                or(byClassNodeNameContains(<span class="string"><span class="delimiter">'</span><span class="content">Logger</span><span class="delimiter">'</span></span>),
                   byClassNodeNameEndsWith(<span class="string"><span class="delimiter">'</span><span class="content">Example</span><span class="delimiter">'</span></span>)))
        }

    AddLoggerTransformer(<span class="directive">final</span> SourceUnit sourceUnit) {
        <span class="local-variable">super</span>(sourceUnit, CRITERIA) <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@Override</span>
    <span class="type">void</span> transformClass(<span class="directive">final</span> ClassNode target) { <i class="conum" data-value="3"></i><b>(3)</b>
        target.addAnnotation(A.NODES.annotation(Log).build())
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Criteria looks for class nodes with name starting with
<code>asteroid.global.samples</code> and nodes containing <code>Logger</code> or nodes
ending with <code>Example</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Applying the criteria in the constructor</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding a note to filtered nodes</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_as_predicates"><a class="anchor" href="#_as_predicates"></a>7.3. As predicates</h3>
<div class="paragraph">
<p>Although criteras were meant to be used in transformers, the way they
were designed makes them perfectly valid to be used as predicates when
filtering lists of AST nodes. The following example ask for all method
nodes from a given class node and then as any Groovy list tries to
find all methods that comply with the filter passed as parameter: <code>all
methods annotated with the <strong>Important</strong> annotation and with a name
starting with <strong>get</strong></code>.</p>
</div>
<div class="listingblock">
<div class="title">Criterias in Local Transformations</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">        <span class="predefined-type">List</span>&lt;MethodNode&gt; notSoImportantMethods = classNode
            .methods
            .findAll(A.CRITERIA.and(A.CRITERIA.byAnnotation(Important),
                                    A.CRITERIA.byMethodNodeNameStartsWith(<span class="string"><span class="delimiter">'</span><span class="content">get</span><span class="delimiter">'</span></span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because criterias are just closures that eventually return a boolean
value they fit perfectly in this scenario.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fluent_api"><a class="anchor" href="#_fluent_api"></a>8. Fluent API</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
With the upcoming <code>groovy-macro</code> module in Groovy 2.5.0 most
of the code in Asteroid, used for creating <code>expressions</code> and
<code>statements</code> may be gone for good in favor of the <code>macro</code> method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main goal of this project is to have a unified way to access all AST APIs through a single entry point. That
entry point is <code>asteroid.A</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>NODES</strong>: Create instances of <code>org.codehaus.groovy.ast.ASTNode</code></p>
</li>
<li>
<p><strong>EXPRESSIONS</strong>: Create instances of <code>org.codehaus.groovy.ast.expr.Expression</code></p>
</li>
<li>
<p><strong>STATEMENTS</strong>: Create instances of <code>org.codehaus.groovy.ast.stmt.Statement</code></p>
</li>
<li>
<p><strong>MODIFIERS</strong>: <code>asteroid.A.ACC</code></p>
</li>
<li>
<p><strong>CHECKERS</strong>: <code>asteroid.A.CHECK</code>. Access to checkers.</p>
</li>
<li>
<p><strong>UTILS</strong>: <code>asteroid.A.UTIL</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The project has been developed having in mind to get the general
idea reading this documentation and then checking the specifics using
the javadoc.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Please check out the javadoc <a href="javadocs/index.html">here</a></p>
</div>
<div class="sect2">
<h3 id="_nodes"><a class="anchor" href="#_nodes"></a>8.1. Nodes</h3>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/Nodes.html"><code>asteroid.A.NODES</code></a></p>
</div>
<div class="paragraph">
<p>This is entry point accesses to a set of builders to create instances of <code>org.codehaus.groovy.ast.ASTNode</code>. All builders
in <code>asteroid.A.NODES</code> follow the same API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">A.NODES.annotation(<span class="string"><span class="delimiter">&quot;</span><span class="content">MyAnnotation</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
       .member(...) <i class="conum" data-value="2"></i><b>(2)</b>
       .xxxxxx(...)
       .yyyyyy(...)
       .build()  <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a builder of a specific type of <code>ASTNode</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then each node builder has a set of associated methods. E.g: <code>annotation</code> has <code>member(&#8230;&#8203;)</code> to add annotation members&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Once the node has been configured is time to create the instance calling the <code>build()</code> method of the
current builder.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For instance, the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">A.NODES.annotation(<span class="string"><span class="delimiter">&quot;</span><span class="content">MyAnnotation</span><span class="delimiter">&quot;</span></span>)
       .member(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>, A.EXPR.constX(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>))
       .member(<span class="string"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span>, A.EXPR.constX(<span class="string"><span class="delimiter">&quot;</span><span class="content">desc</span><span class="delimiter">&quot;</span></span>))
       .build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will produce the following annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@MyAnnotation</span>(message = <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>, sort = <span class="string"><span class="delimiter">&quot;</span><span class="content">desc</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The nodes related javadoc has the same structure. Normally
you&#8217;ll see the AST and the resulting code explained.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_expressions_2"><a class="anchor" href="#_expressions_2"></a>8.2. Expressions</h3>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/Expressions.html"><code>asteroid.A.EXPR</code></a></p>
</div>
<div class="paragraph">
<p>This entry point accesses to a set of methods returning instances of <code>org.codehaus.groovy.ast.expr.Expression</code>.</p>
</div>
<div class="paragraph">
<p>Unlike the <code>asteroid.A.NODES</code> this entry point only has methods creating expressions directly. So bear in mind that
all methods from <code>asteroid.A.EXPR</code> will return instances of <code>org.codehaus.groovy.ast.Expression</code>.</p>
</div>
<div class="paragraph">
<p>For instance if we would like to create an expression like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">println <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We should code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">A.EXPR.callThisX( <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">println</span><span class="delimiter">&quot;</span></span>,
    A.EXPR.constX(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates an instance of <code>org.codehaus.groovy.ast.expr.MethodCallExpression</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates an instance of <code>org.codehaus.groovy.ast.expr.ConstantExpression</code> used as method call argument.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Why using <code>callThisX</code> when coding <code>println</code> ? This is because <code>println</code> is added to all JDK objects
through the <code>DefaultGroovyMethods</code> object.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_statements_2"><a class="anchor" href="#_statements_2"></a>8.3. Statements</h3>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/Statements.html"><code>asteroid.A.STMT</code></a></p>
</div>
<div class="quoteblock">
<blockquote>
In computer programming a statement is the smallest standalone element of an imperative programming language that
expresses some action to be carried out. It is an instruction written in a high-level language that commands the
computer to perform a specified action.[1] A program written in such a language is formed by a sequence of one or
more statements. A statement may have internal components (e.g., expressions).
</blockquote>
<div class="attribution">
&#8212; Wikipedia
</div>
</div>
<div class="paragraph">
<p>This entry point accesses to a set of methods returning instances of <code>org.codehaus.groovy.ast.stmt.Statement</code>. It
follows the same design as expressions. Each method returns an statement. For instance, a return statement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">return</span> <span class="integer">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Can be written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">A.STMT.returnS(A.EXPR.constX(<span class="integer">1</span>))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modifiers"><a class="anchor" href="#_modifiers"></a>8.4. Modifiers</h3>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/Modifiers.html"><code>asteroid.A.ACC</code></a></p>
</div>
<div class="paragraph">
<p>When creating a node we may want to restrict its visibility, or mark it as <code>static</code>&#8230;&#8203;etc. To do that each node
has a method called <code>setModifiers(int)</code>. That value can be built with one or more values from this entry point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">A.ACC.ACC_PUBLIC <span class="comment">// public</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utils"><a class="anchor" href="#_utils"></a>8.5. Utils</h3>
<div class="paragraph">
<p>Check javadoc: <a href="javadocs/asteroid/Utils.html"><code>asteroid.A.UTIL</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.5.0<br>
Last updated 2022-11-28 23:45:28 +0100
</div>
</div>
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>